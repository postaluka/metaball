"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VolumeNew = exports.Volume = void 0;
const Cube_1 = require("./Cube");
const three_1 = require("three");
const simplex_noise_1 = require("simplex-noise");
const Noise_1 = require("../Noise");
const util_1 = require("./util");
const lookup_json_1 = require("./lookup.json");
const perlin_js_1 = require("perlin.js");
class Volume {
    size;
    cubeGrid = [];
    wireframeCube = new three_1.BufferGeometry;
    wireframeMesh;
    position;
    geometry = new three_1.BufferGeometry();
    showEdges = true;
    edgeSharpness = 1.1;
    show = true;
    noiseOffset = new three_1.Vector3(0, 0, 0);
    noiseScale = 4;
    densityThreshold = 1;
    yBias = 0;
    gridWireframe = false;
    wireFrame = false;
    seed = 0;
    noiseSeed = 0;
    pNoiseSeed = Volume.createSeed(this.seed);
    ySize = 0;
    noise = {
        perlin: {
            "2D": perlin_js_1.perlin2,
            "3D": perlin_js_1.perlin3,
        },
        simplex: {
            "2D": (0, simplex_noise_1.createNoise2D)(),
            "3D": (0, simplex_noise_1.createNoise3D)(),
        }
    };
    static createSeed(_seed) {
        return (0, perlin_js_1.seed)(_seed);
    }
    constructor(size, position) {
        this.size = size;
        this.ySize = size / 2;
        this.seed = Date.now();
        this.pNoiseSeed = (0, perlin_js_1.seed)(this.seed);
        // If the position is not zero, divide it by the size of the volume
        // This is to make sure that the volume is centered around the position
        this.position = position.clone().divideScalar(size);
        this.noiseOffset = this.position.clone();
        this.yBias = this.ySize;
        this.generateGrid();
    }
    generateGrid() {
        const boxGeos = new Array(this.size * this.size * this.size);
        for (let z = 0; z < this.size; z++) {
            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    // Get the index
                    const index = x + y * this.size + z * this.size * this.size;
                    // When setting the cube position, we need to take into account the position of the volume
                    const cubePosition = new three_1.Vector3(x, y, z);
                    this.cubeGrid[index] = new Cube_1.default(this, cubePosition);
                    boxGeos[index] = new three_1.BoxGeometry(1, 1, 1);
                    boxGeos[index].translate(x, y, z);
                    boxGeos[index].translate(0.5, 0.5, 0.5);
                }
            }
        }
        this.wireframeCube = this.mergeGeometries(boxGeos);
        // Create the mesh
        this.wireframeMesh = new three_1.Mesh(this.wireframeCube, new three_1.MeshBasicMaterial({ color: 0x000000, wireframe: true }));
        this.wireframeMesh.name = "VolumeWireframe";
        this.update("wireframe");
    }
    enableWireFrame(scene) {
        if (this.wireframeMesh != undefined) {
            scene.add(this.wireframeMesh);
        }
    }
    update(key) {
        if (key.toLowerCase() == "geometry") {
            this.geometry.dispose();
            this.geometry = this.mergeGeometries(this.March(true));
            this.geometry.computeVertexNormals();
        }
    }
    March(updateValues = false) {
        this.noiseSeed = (0, perlin_js_1.seed)(this.seed);
        let cubeGeometries = [];
        this.cubeGrid = [];
        this.generateGrid();
        // For each cube in the grid
        for (let z = 0; z < this.size - 1; z++) {
            for (let y = 0; y < this.size - 1; y++) {
                for (let x = 0; x < this.size - 1; x++) {
                    // Get the index
                    const index = x + y * this.size + z * this.size * this.size;
                    // Get the cube
                    let cube = this.cubeGrid[index];
                    // Build the mesh
                    const cubeGeometry = cube.buildMesh(updateValues);
                    if (cubeGeometry.getAttribute("position") != null || cubeGeometry.getAttribute("position") != undefined) {
                        cubeGeometries.push(cubeGeometry);
                    }
                }
            }
        }
        return cubeGeometries;
    }
    mergeGeometries(geometries) {
        const finalGeometry = new three_1.BufferGeometry();
        const vertices = [];
        const uvs = [];
        for (let i = 0; i < geometries.length; i++) {
            const geometry = geometries[i];
            const position = geometry.getAttribute('position');
            const uv = geometry.getAttribute('uv');
            for (let i = 0; i < position.count; i++) {
                vertices.push(position.getX(i), position.getY(i), position.getZ(i));
            }
            for (let i = 0; i < uv.count; i++) {
                uvs.push(uv.getX(i), uv.getY(i));
            }
        }
        finalGeometry.setAttribute('position', new three_1.Float32BufferAttribute(vertices, 3));
        finalGeometry.setAttribute('uv', new three_1.Float32BufferAttribute(uvs, 2));
        finalGeometry.computeVertexNormals();
        this.geometry = finalGeometry;
        return finalGeometry;
    }
    static mergeGeometries(geometries) {
        const finalGeometry = new three_1.BufferGeometry();
        const vertices = [];
        const uvs = [];
        for (let i = 0; i < geometries.length; i++) {
            const geometry = geometries[i];
            const position = geometry.getAttribute('position');
            const uv = geometry.getAttribute('uv');
            for (let j = 0; j < position.count; j++) {
                vertices.push(position.getX(j), position.getY(j), position.getZ(j));
            }
            for (let j = 0; j < uv.count; j++) {
                uvs.push(uv.getX(j), uv.getY(j));
            }
        }
        finalGeometry.setAttribute('position', new three_1.Float32BufferAttribute(vertices, 3));
        finalGeometry.setAttribute('uv', new three_1.Float32BufferAttribute(uvs, 2));
        finalGeometry.computeVertexNormals();
        return finalGeometry;
    }
    getPosition() {
        return this.position;
    }
    getDensityThreshold() {
        return this.densityThreshold;
    }
    getNoiseScale() {
        return this.noiseScale;
    }
    getScale() {
        return this.size;
    }
    getNoiseOffset() {
        // return new Vector3(this.noiseOffsetX, this.noiseOffsetY, this.noiseOffsetZ);
        return this.noiseOffset;
    }
    getGeometry() {
        return this.geometry;
    }
    isShowingEdges() {
        return this.showEdges;
    }
    isWireFrame() {
        return this.wireFrame;
    }
}
exports.Volume = Volume;
class VolumeNew {
    static cubeCorners = [
        new three_1.Vector3(0, 0, 0),
        new three_1.Vector3(1, 0, 0),
        new three_1.Vector3(1, 0, 1),
        new three_1.Vector3(0, 0, 1),
        new three_1.Vector3(0, 1, 0),
        new three_1.Vector3(1, 1, 0),
        new three_1.Vector3(1, 1, 1),
        new three_1.Vector3(0, 1, 1)
    ];
    size;
    position = new three_1.Vector3(0, 0, 0);
    vertices = [];
    uvs = [];
    densities = [];
    geometry = new three_1.BufferGeometry();
    showEdges = false;
    edgeSharpness = 1.1;
    show = true;
    noiseOffset = new three_1.Vector3(0, 0, 0);
    noiseScale = 4;
    densityThreshold = 1;
    yBias = 0;
    seed = 0;
    noiseSeed = 0;
    pNoiseSeed = Volume.createSeed(this.seed);
    ySize = 0;
    customNoise = new Noise_1.Noise(this.seed);
    noiseConfigs = [];
    neighbours = {
        front: null,
        back: null,
        left: null,
        right: null,
        frontLeft: null,
        frontRight: null,
        backLeft: null,
        backRight: null
    };
    noise = {
        perlin: {
            "2D": perlin_js_1.perlin2,
            "3D": perlin_js_1.perlin3,
        },
        simplex: {
            "2D": (0, simplex_noise_1.createNoise2D)(),
            "3D": (0, simplex_noise_1.createNoise3D)(),
        }
    };
    constructor(size, position, noiseOffset = new three_1.Vector3(0, 0, 0)) {
        this.size = size;
        this.position = position;
        this.noiseOffset = noiseOffset;
        this.ySize = this.size / 2;
        this.yBias = this.ySize;
        this.noiseConfigs.push({
            'scale': 1,
            'octaves': 4,
            'persistence': 0.5,
            'lacunarity': 2,
            'offset': new three_1.Vector3(0, 0, 0)
        });
    }
    update(key) {
        if (key.toLowerCase() == "geometry") {
            this.geometry.dispose();
            this.March();
            this.geometry.computeVertexNormals();
        }
        // if(key.toLowerCase() == "noise") {
        //     for(let i = 0; i < this.noiseConfigs.length; i++) {
        //         this.noiseConfigs[i].offset = this.position.clone().multiplyScalar(this.noiseConfigs[i].scale);
        //     }
        // }
    }
    March() {
        this.noiseSeed = (0, perlin_js_1.seed)(this.seed);
        this.vertices = [];
        this.densities = [];
        this.uvs = [];
        let frontNeighbour = this.neighbours.front;
        let backNeighbour = this.neighbours.back;
        let leftNeighbour = this.neighbours.left;
        let rightNeighbour = this.neighbours.right;
        let frontLeftNeighbour = this.neighbours.frontLeft;
        let frontRightNeighbour = this.neighbours.frontRight;
        let backLeftNeighbour = this.neighbours.backLeft;
        let backRightNeighbour = this.neighbours.backRight;
        let zSize = (frontNeighbour == null) ? this.size - 1 : this.size;
        let xSize = (rightNeighbour == null) ? this.size - 1 : this.size;
        // For each cube in the grid
        for (let z = 0; z < zSize; z++) {
            for (let y = 0; y < this.size - 1; y++) {
                for (let x = 0; x < xSize; x++) {
                    let cubeindex = 0;
                    let cubePosition = new three_1.Vector3(x, y, z);
                    let corners = [];
                    let cornerDensity = [];
                    VolumeNew.cubeCorners.forEach((corner, i) => {
                        let cornerPos = corner.clone();
                        cornerPos.add(cubePosition);
                        let noise = 0;
                        // For each noise config, add the noise
                        for (let config of this.noiseConfigs) {
                            let cPosition = cornerPos.clone();
                            cPosition.z -= zSize * 0.5;
                            cPosition.x -= xSize * 0.5;
                            cPosition.divideScalar(this.getScale());
                            const volumePosition = this.position.clone().multiplyScalar(config.scale);
                            let newNoise = this.customNoise.generate3DFBM(cPosition, config, volumePosition);
                            noise += (newNoise * (1 / this.noiseConfigs.length));
                        }
                        // let noise = this.customNoise.generate3D(, this.noiseScale, 1, 1, 1, this.noiseOffset);
                        noise = (noise + 1) / 2;
                        let heightBias = (cornerPos.y / this.getScale());
                        let density = heightBias * (cornerPos.y / this.yBias || 0.001) - noise;
                        cornerDensity[i] = density;
                        corners[i] = new three_1.Vector4(cornerPos.x, cornerPos.y, cornerPos.z, density);
                    });
                    for (let i = 0; i < 8; i++) {
                        const corner = corners[i];
                        // If the corner at at the top of the volume,
                        // the corner.w will be 1, otherwise it will be 0
                        const cornerIsAtTop = corner.y == this.getScale() - 1;
                        const cornerIsAtBottom = corner.y == 0;
                        const cornerIsAtRight = corner.x == this.getScale() - 1;
                        const cornerIsAtLeft = corner.x == 0;
                        const cornerIsAtFront = corner.z == this.getScale() - 1;
                        const cornerIsAtBack = corner.z == 0;
                        const showFrontFace = (cornerIsAtFront && !frontNeighbour) && z == this.size - 2;
                        const showBackFace = (cornerIsAtBack && !backNeighbour) && z == 0;
                        const showRightFace = (cornerIsAtRight && !rightNeighbour) && x == this.size - 2;
                        const showLeftFace = (cornerIsAtLeft && !leftNeighbour) && x == 0;
                        if (showFrontFace)
                            corner.w = (this.showEdges) ? this.edgeSharpness : cornerDensity[i];
                        if (showBackFace)
                            corner.w = (this.showEdges) ? this.edgeSharpness : cornerDensity[i];
                        if (showRightFace)
                            corner.w = (this.showEdges) ? this.edgeSharpness : cornerDensity[i];
                        if (showLeftFace)
                            corner.w = (this.showEdges) ? this.edgeSharpness : cornerDensity[i];
                        if (cornerIsAtBottom)
                            corner.w = (this.showEdges) ? this.edgeSharpness : cornerDensity[i];
                        if (cornerIsAtTop)
                            corner.w = (this.showEdges) ? this.edgeSharpness : cornerDensity[i];
                        if (corner.w <= this.getDensityThreshold()) {
                            cubeindex |= 1 << i;
                        }
                    }
                    /* Cube is entirely in/out of the surface */
                    if (lookup_json_1.edgeTable[cubeindex] == 0) {
                        continue;
                    }
                    const triangluation = lookup_json_1.triTable[cubeindex];
                    triangluation.forEach(edge => {
                        if (edge == -1)
                            return;
                        let indexA = lookup_json_1.cornerIndexFromEdge[edge][0];
                        let indexB = lookup_json_1.cornerIndexFromEdge[edge][1];
                        let cornerA = corners[indexA];
                        let cornerB = corners[indexB];
                        let vert = (0, util_1.VertexInterp3)(this.getDensityThreshold(), cornerA, cornerB);
                        // Get the vertex
                        // Don't interpolate
                        // let vert = cornerA.clone();
                        // vert.add(cornerB);
                        // vert.divideScalar(2);
                        this.vertices.push(vert.x, vert.y, vert.z);
                        // Create UV  from vert
                        let uvVert = vert.clone().divideScalar(this.getScale());
                        this.uvs.push(uvVert.x, uvVert.z);
                    });
                }
            }
        }
        // Create the geometry
        this.geometry = new three_1.BufferGeometry();
        this.geometry.setAttribute('position', new three_1.Float32BufferAttribute(this.vertices, 3));
        this.geometry.setAttribute('uv', new three_1.Float32BufferAttribute(this.uvs, 2));
        this.geometry.computeVertexNormals();
        this.geometry.translate(this.position.x * this.size, this.position.y * this.size, this.position.z * this.size);
    }
    getDensityThreshold() {
        return this.densityThreshold;
    }
    getHeightmap(scale = 1) {
        const heightMap = [];
        const heightMapper = new three_1.Raycaster();
        const mesh = new three_1.Mesh(this.geometry, new three_1.MeshBasicMaterial({ color: 0x000000 }));
        // Calculate the size based on the scale
        // Where 1 is the size of the volume
        // Where 2 is half the size of the volume
        for (let x = Number(this.showEdges); x < this.size - Number(this.showEdges); x += scale) {
            for (let z = Number(this.showEdges); z < this.size - Number(this.showEdges); z += scale) {
                const point = new three_1.Vector3(x, this.size * 2, z);
                heightMapper.set(point, new three_1.Vector3(0, -1, 0));
                const intersects = heightMapper.intersectObject(mesh);
                if (intersects.length === 0) {
                    continue;
                }
                else {
                    heightMap.push({
                        point: intersects[0].point,
                        normal: intersects[0].face?.normal.clone().normalize() || new three_1.Vector3(0, 1, 0)
                    });
                }
            }
        }
        return heightMap;
    }
    getNoiseScale() {
        return this.noiseScale;
    }
    getScale() {
        return this.size;
    }
    getGeometry() {
        return this.geometry;
    }
    isShowingEdges() {
        return this.showEdges;
    }
}
exports.VolumeNew = VolumeNew;
exports.default = { Volume, VolumeNew, NoiseData: Noise_1.NoiseData };
