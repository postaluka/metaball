"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cube = void 0;
const three_1 = require("three");
const util_1 = require("./util");
const lookup_json_1 = require("./lookup.json");
class Cube {
    position = new three_1.Vector3;
    static cornersIndex = [
        new three_1.Vector3(0, 0, 0),
        new three_1.Vector3(1, 0, 0),
        new three_1.Vector3(1, 0, 1),
        new three_1.Vector3(0, 0, 1),
        new three_1.Vector3(0, 1, 0),
        new three_1.Vector3(1, 1, 0),
        new three_1.Vector3(1, 1, 1),
        new three_1.Vector3(0, 1, 1)
    ];
    corners = [];
    cornerDensity = [];
    volume;
    geometry;
    noise;
    constructor(volume, position) {
        this.volume = volume;
        this.noise = volume.noise;
        this.geometry = new three_1.BufferGeometry();
        this.updatePosition(position);
        this.generateValues();
    }
    generateValues() {
        this.corners = new Array(8);
        this.cornerDensity = new Array(8);
        this.noise = this.volume.noise;
        // for(let i = 0; i < Cube.cornersIndex.length; i++) {
        //     let corner = Cube.cornersIndex[i].clone().add(this.position);
        //     let value = this.noise["3D"](corner.x, corner.y, corner.z);
        //     this.corners[i] = new Vector4(corner.x, corner.y, corner.z, value);
        // }
        Cube.cornersIndex.forEach((corner, i) => {
            let cornerPos = corner.clone();
            cornerPos.add(this.position);
            let xCoord = (cornerPos.x / this.volume.getScale()) * this.volume.getNoiseScale() + this.volume.getNoiseOffset().x;
            let yCoord = (cornerPos.y / this.volume.getScale()) * this.volume.getNoiseScale() + this.volume.getNoiseOffset().y;
            let zCoord = (cornerPos.z / this.volume.getScale()) * this.volume.getNoiseScale() + this.volume.getNoiseOffset().z;
            // Offset the noise to the center of the volume
            xCoord -= this.volume.getScale() / 2;
            yCoord -= this.volume.getScale() / 2;
            zCoord -= this.volume.getScale() / 2;
            let noiseValue = this.noise.perlin["3D"](xCoord, yCoord, zCoord);
            const heightBias = (cornerPos.y / this.volume.getScale());
            const density = heightBias * (cornerPos.y / this.volume.yBias) - noiseValue;
            // Invert the density
            //density = 1 - density;
            this.corners[i] = new three_1.Vector4(cornerPos.x, cornerPos.y, cornerPos.z, density);
            this.cornerDensity[i] = density;
        });
    }
    updatePosition(position) {
        this.position = position;
    }
    buildMesh(updateValues = false) {
        let cubeindex = 0;
        let vertlist = [];
        let uvlist = [];
        if (updateValues) {
            this.generateValues();
        }
        for (let i = 0; i < 8; i++) {
            const corner = this.corners[i];
            // If the corner at at the top of the volume,
            // the corner.w will be 1, otherwise it will be 0
            const cornerIsAtTop = corner.y == this.volume.getScale() - 1;
            const cornerIsAtBottom = corner.y == 0;
            const cornerIsAtRight = corner.x == this.volume.getScale() - 1;
            const cornerIsAtLeft = corner.x == 0;
            const cornerIsAtFront = corner.z == this.volume.getScale() - 1;
            const cornerIsAtBack = corner.z == 0;
            if ((cornerIsAtTop || cornerIsAtBottom || cornerIsAtRight || cornerIsAtLeft || cornerIsAtFront || cornerIsAtBack)) {
                corner.w = (this.volume.showEdges) ? this.volume.edgeSharpness : this.cornerDensity[i];
            }
            if (corner.w <= this.volume.getDensityThreshold()) {
                cubeindex |= 1 << i;
            }
        }
        /* Cube is entirely in/out of the surface */
        if (lookup_json_1.edgeTable[cubeindex] == 0)
            return new three_1.BufferGeometry();
        const triangluation = lookup_json_1.triTable[cubeindex];
        triangluation.forEach(edge => {
            if (edge == -1)
                return;
            let indexA = lookup_json_1.cornerIndexFromEdge[edge][0];
            let indexB = lookup_json_1.cornerIndexFromEdge[edge][1];
            let cornerA = this.corners[indexA];
            let cornerB = this.corners[indexB];
            let vert = (0, util_1.VertexInterp3)(this.volume.getDensityThreshold(), cornerA, cornerB);
            vertlist.push(vert);
            // Create UV  from vert
            let uvVert = vert.clone().divideScalar(this.volume.getScale());
            uvlist.push(new three_1.Vector2(uvVert.x, uvVert.z));
        });
        // Convert the vertex list to a float32 array
        let vertices = new Array(vertlist.length * 3);
        let uvs = new Array(uvlist.length * 2);
        for (let i = 0; i < vertlist.length; i++) {
            vertices.push(vertlist[i].x, vertlist[i].y, vertlist[i].z);
        }
        for (let i = 0; i < uvlist.length; i++) {
            uvs.push(uvlist[i].x, uvlist[i].y);
        }
        // Create the geometry
        this.geometry = new three_1.BufferGeometry();
        this.geometry.setAttribute('position', new three_1.Float32BufferAttribute(vertices, 3));
        this.geometry.setAttribute('uv', new three_1.Float32BufferAttribute(uvs, 2));
        this.geometry.computeVertexNormals();
        return this.geometry;
    }
}
exports.Cube = Cube;
exports.default = Cube;
