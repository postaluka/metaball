"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Noise = exports.NoiseData = void 0;
const perlin_js_1 = require("perlin.js");
const simplex_noise_1 = require("simplex-noise");
const three_1 = require("three");
exports.NoiseData = {
    offset: new three_1.Vector3(0, 0, 0),
    scale: 1,
    octaves: 1,
    persistence: 1,
    lacunarity: 1,
};
class Noise {
    noise = {
        perlin: {
            "2D": perlin_js_1.perlin2,
            "3D": perlin_js_1.perlin3,
        },
        simplex: {
            "2D": (0, simplex_noise_1.createNoise2D)(),
            "3D": (0, simplex_noise_1.createNoise3D)(),
        }
    };
    seed = 0;
    noiseType = "perlin";
    constructor(_seed) {
        this.seed = _seed;
    }
    static createSeed(_seed = 1) {
        // If the seed is 0, or more than 65536, then get the modulus of the seed
        while (_seed === 0 || _seed > 65536) {
            _seed = _seed % 65536;
        }
        (0, perlin_js_1.seed)(_seed);
    }
    setType(type) {
        switch (type) {
            case "perlin":
            case "simplex":
                this.noiseType = type;
                break;
            default:
                console.error("Noise type not found");
                console.warn("Defaulting to perlin noise");
                this.noiseType = "perlin";
                break;
        }
    }
    generate3D(position, noiseData) {
        Noise.createSeed(this.seed * (position.x + position.y + position.z));
        let noise = this.noise[this.noiseType]["3D"];
        if (noiseData.scale <= 0) {
            noiseData.scale = 0.0001;
        }
        let coord = position.clone().multiplyScalar(noiseData.scale).add(noiseData.offset);
        let perlinValue = noise(coord.x, coord.y, coord.z);
        return perlinValue;
    }
    generate3DFBM(position, noiseData, offset) {
        let noise = this.noise[this.noiseType]["3D"];
        let maxPossibleHeight = 0;
        let amplitude = 1;
        let frequency = 1;
        for (let i = 0; i < noiseData.octaves; i++) {
            maxPossibleHeight += amplitude;
            amplitude *= noiseData.persistence;
        }
        if (noiseData.scale <= 0) {
            noiseData.scale = 0.0001;
        }
        // Get max and min values of Float
        let max = Number.MAX_VALUE;
        let min = Number.MIN_VALUE;
        let noiseHeight = 0;
        amplitude = 1;
        frequency = 1;
        for (let i = 0; i < noiseData.octaves; i++) {
            let coord = position.clone().multiplyScalar(noiseData.scale * frequency).add(offset).add(noiseData.offset);
            let perlinValue = noise(coord.x, coord.y, coord.z);
            noiseHeight += perlinValue * amplitude;
            amplitude *= noiseData.persistence;
            frequency *= noiseData.lacunarity;
        }
        if (noiseHeight > max) {
            max = noiseHeight;
        }
        else if (noiseHeight < min) {
            min = noiseHeight;
        }
        return noiseHeight;
    }
}
exports.Noise = Noise;
exports.default = { Noise, NoiseData: exports.NoiseData };
